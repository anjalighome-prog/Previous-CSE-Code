import java.util.*;
import java.io.*;

public class Absurdle  {
    public static final String GREEN = "ðŸŸ©";
    public static final String YELLOW = "ðŸŸ¨";
    public static final String GRAY = "â¬œ";

    // [[ ALL OF MAIN PROVIDED ]]
    public static void main(String[] args) throws FileNotFoundException {
        Scanner console = new Scanner(System.in);
        System.out.println("Welcome to the game of Absurdle.");

        System.out.print("What dictionary would you like to use? ");
        String dictName = console.next();

        System.out.print("What length word would you like to guess? ");
        int wordLength = console.nextInt();

        List<String> contents = loadFile(new Scanner(new File(dictName)));
        Set<String> words = pruneDictionary(contents, wordLength);

        List<String> guessedPatterns = new ArrayList<>();
        while (!isFinished(guessedPatterns)) {
            System.out.print("> ");
            String guess = console.next();
            String pattern = recordGuess(guess, words, wordLength);
            guessedPatterns.add(pattern);
            System.out.println(": " + pattern);
            System.out.println();
        }
        System.out.println("Absurdle " + guessedPatterns.size() + "/âˆž");
        System.out.println();
        printPatterns(guessedPatterns);
    }

    // [[ PROVIDED ]]
    // Prints out the given list of patterns.
    // - List<String> patterns: list of patterns from the game
    public static void printPatterns(List<String> patterns) {
        for (String pattern : patterns) {
            System.out.println(pattern);
        }
    }

    // [[ PROVIDED ]]
    // Returns true if the game is finished, meaning the user guessed the word. Returns
    // false otherwise.
    // - List<String> patterns: list of patterns from the game
    public static boolean isFinished(List<String> patterns) {
        if (patterns.isEmpty()) {
            return false;
        }
        String lastPattern = patterns.get(patterns.size() - 1);
        return !lastPattern.contains("â¬œ") && !lastPattern.contains("ðŸŸ¨");
    }

    // [[ PROVIDED ]]
    // Loads the contents of a given file Scanner into a List<String> and returns it.
    // - Scanner dictScan: contains file contents
    public static List<String> loadFile(Scanner dictScan) {
        List<String> contents = new ArrayList<>();
        while (dictScan.hasNext()) {
            contents.add(dictScan.next());
        }
        return contents;
    }

    // Behavior:
    // - This method finds all the words in the given set that are the correct lenth (given by the
    //   user)
    // Exceptions:
    // - IllegalArgumentException: If the given length is less than 1
    // Returns:
    // - Set<String>: the words that are of the given length
    // Parameters:
    // - contents: List of strings given from a file
    // - wordLength: user input of word length they want to guess 
    public static Set<String> pruneDictionary(List<String> contents, int wordLength) 
                                        throws IllegalArgumentException
    {
        if(wordLength < 1) // if the word length is not long enough for a word
        {
            throw new IllegalArgumentException();
        }
        Set<String> correctLength = new HashSet<>();
        for(int i = 0; i < contents.size(); i++)
        {
            if(contents.get(i).length() == wordLength) // if it is the right length
            {
                correctLength.add(contents.get(i));
            }
        }
        return correctLength;
    }

    // Behavior:
    // - This method finds the color pattern that has the most words associated to if based on
    //   guess word. The set of initial words will be narrowed down to the set of words associated
    //   with the pattern returned.
    // Exceptions:
    // - IllegalArgumentException: If the length of the guess word is not equal to the inputed
    //   word length
    // Returns:
    // - String: the color pattern that has the most words associated to if based on guess word
    // Parameters:
    // - wordLength: user input of word length they want to guess 
    // - guess: the word that user has guessed
    // - words: The words that the user can match with
    public static String recordGuess(String guess, Set<String> words, int wordLength) 
                                            throws IllegalArgumentException
    {
        if(guess.length() < wordLength || guess.length() > wordLength)
        {
            throw new IllegalArgumentException();
        }
        if(words.size() == 0)
        {
            throw new IllegalArgumentException();
        }
        Map<String, Set<String>> patterns = populateMap(words, guess);
        int maxLength = 0;
        String patternReturn = "";
        for(String p: patterns.keySet())
        {
            Set<String> curr = patterns.get(p);
            if(curr.size() > maxLength)
            {
                maxLength = curr.size();
                patternReturn = p;
            }
        }

        Set<String> temp = patterns.get(patternReturn);
        Iterator<String> i = words.iterator();
        while(i.hasNext())
        {
            String curr = i.next();
            if(!(temp.contains(curr)))
            {
                i.remove();
            }
        }
        return patternReturn;
    }

    // Behavior:
    // - The method finds the words that have the same color coded pattern based on the guess
    //   and then groups them together in that way
    // Exceptions:
    // - None
    // Returns:
    // - Map<String, Set<String>>: the color coded pattern based on guess word, with the words 
    //   from the dictionary set that have
    // Parameters:
    // - guess: the word that user has guessed
    // - words: The words that the user can match with
    public static Map<String, Set<String>> populateMap(Set<String> words, String guess)
    {
        Map<String, Set<String>> patterns = new TreeMap<>();
        for(String word: words)
        {
            String pattern = patternFor(word, guess); // get color coded
            if(!(patterns.containsKey(pattern))) // if new pattern, add to the map
            {
                Set<String> newPattern = new HashSet<>();
                newPattern.add(word);
                patterns.put(pattern, newPattern);
            }
            else
            {
                patterns.get(pattern).add(word); // add to the existing set
            }
        }
        return patterns;
    }

    // Behavior:
    // - This method takes in two words, guess and goal, and makes the accuracy pattern signified
    //    with colors to indicate use and positioning of a certain letter
    // Exceptions:
    // - None
    // Returns:
    // - String: accuracy pattern signified with colors to indicate use and positioning of a 
    //    certain letter
    // Parameters:
    // - word: the word that the guess is being compared to
    // - guess: the word that user has guessed
    public static String patternFor(String word, String guess) {
        // Will store character and number of occurences
        Map<Character, Integer> numLeft = new TreeMap<>();
        // Will store each letter in guess
        List<String> compare = new ArrayList<>();

        int count;
        for(int i = 0; i < word.length(); i++)
        {
            count = 0;
            char current = word.charAt(i);
            if(!(numLeft.containsKey(current))) // the character isn't in the Map
            {
                String curString = "" + current + "";
                String newWord = word.substring(0); // to make sure that the original is not modified
                while(newWord.contains(curString)) // if the word still has the character
                {
                    count++; // updat counter
                    // condense the word so that counter will be accurate
                    newWord = newWord.substring(0, newWord.indexOf(current)) + newWord.substring(newWord.indexOf(current) + 1);
                }
                numLeft.put(current, count); // put in the map
            }
        }

        // copy letters in list
        for(int i = 0; i < guess.length(); i++)
        {
            String character = "" + guess.charAt(i);
            compare.add(character);
        }

        for(int i = 0; i < word.length(); i++)
        {
            if(guess.charAt(i) == word.charAt(i)) // compares the characters at a position
            {
                char current = guess.charAt(i); // make a variable for ease
                compare.set(i, GREEN);
                int curInt = numLeft.get(current);
                numLeft.replace(current, curInt, curInt - 1);
            }
        }

        // color codes the rest of the guess word
        for(int i = 0; i < guess.length(); i++)
        {
            char current = guess.charAt(i);
            if(!(compare.get(i).equals(GREEN)))
            {
                // if the word has the character and there are still more of that letter in the
                // the original word
                if((numLeft.containsKey(current)) && (numLeft.get(current) != 0))
                {
                    compare.set(i, YELLOW);
                    int curInt = numLeft.get(current);
                    numLeft.replace(current, curInt, curInt - 1);
                }
                else // if the original word does not have the letter
                {
                    compare.set(i, GRAY);
                }
            }
        }

        // transfers into a string
        String returnString = "";
        for(int i = 0; i < compare.size(); i++)
        {
            returnString = returnString + compare.get(i);
        }

        return returnString;
    }
}